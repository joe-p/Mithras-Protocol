// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import * as wasmBundle from "./wasm-bindgen/index.js";
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArrayBuffer,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(
  () => new wasmBundle.RustCallStatus(),
);

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

export type HpkeEnvelope = {
  version: /*u8*/ number;
  suite: /*u8*/ number;
  encapsulatedKey: ArrayBuffer;
  ciphertext: ArrayBuffer;
  discoveryTag: ArrayBuffer;
};

/**
 * Generated factory for {@link HpkeEnvelope} record objects.
 */
export const HpkeEnvelope = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HpkeEnvelope, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HpkeEnvelope}, with defaults specified
     * in Rust, in the {@link mithras_crypto_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HpkeEnvelope}, with defaults specified
     * in Rust, in the {@link mithras_crypto_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link mithras_crypto_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HpkeEnvelope>,
  });
})();

const FfiConverterTypeHpkeEnvelope = (() => {
  type TypeName = HpkeEnvelope;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        version: FfiConverterUInt8.read(from),
        suite: FfiConverterUInt8.read(from),
        encapsulatedKey: FfiConverterArrayBuffer.read(from),
        ciphertext: FfiConverterArrayBuffer.read(from),
        discoveryTag: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt8.write(value.version, into);
      FfiConverterUInt8.write(value.suite, into);
      FfiConverterArrayBuffer.write(value.encapsulatedKey, into);
      FfiConverterArrayBuffer.write(value.ciphertext, into);
      FfiConverterArrayBuffer.write(value.discoveryTag, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt8.allocationSize(value.version) +
        FfiConverterUInt8.allocationSize(value.suite) +
        FfiConverterArrayBuffer.allocationSize(value.encapsulatedKey) +
        FfiConverterArrayBuffer.allocationSize(value.ciphertext) +
        FfiConverterArrayBuffer.allocationSize(value.discoveryTag)
      );
    }
  }
  return new FFIConverter();
})();

export type TransactionMetadata = {
  sender: ArrayBuffer;
  firstValid: /*u64*/ bigint;
  lastValid: /*u64*/ bigint;
  lease: ArrayBuffer;
  network: string;
  appId: /*u64*/ bigint;
};

/**
 * Generated factory for {@link TransactionMetadata} record objects.
 */
export const TransactionMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TransactionMetadata, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TransactionMetadata}, with defaults specified
     * in Rust, in the {@link mithras_crypto_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TransactionMetadata}, with defaults specified
     * in Rust, in the {@link mithras_crypto_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link mithras_crypto_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TransactionMetadata>,
  });
})();

const FfiConverterTypeTransactionMetadata = (() => {
  type TypeName = TransactionMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sender: FfiConverterArrayBuffer.read(from),
        firstValid: FfiConverterUInt64.read(from),
        lastValid: FfiConverterUInt64.read(from),
        lease: FfiConverterArrayBuffer.read(from),
        network: FfiConverterString.read(from),
        appId: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.sender, into);
      FfiConverterUInt64.write(value.firstValid, into);
      FfiConverterUInt64.write(value.lastValid, into);
      FfiConverterArrayBuffer.write(value.lease, into);
      FfiConverterString.write(value.network, into);
      FfiConverterUInt64.write(value.appId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.sender) +
        FfiConverterUInt64.allocationSize(value.firstValid) +
        FfiConverterUInt64.allocationSize(value.lastValid) +
        FfiConverterArrayBuffer.allocationSize(value.lease) +
        FfiConverterString.allocationSize(value.network) +
        FfiConverterUInt64.allocationSize(value.appId)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = (() => {
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  return {
    stringToBytes: (s: string) => encoder.encode(s),
    bytesToString: (ab: UniffiByteArray) => decoder.decode(ab),
    stringByteLength: (s: string) => encoder.encode(s).byteLength,
  };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: MithrasCryptoError

// Enum: MithrasCryptoError
export enum MithrasCryptoError_Tags {
  Error = "Error",
}
export const MithrasCryptoError = (() => {
  type Error__interface = {
    tag: MithrasCryptoError_Tags.Error;
    inner: Readonly<[string]>;
  };

  class Error_ extends UniffiError implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "MithrasCryptoError";
    readonly tag = MithrasCryptoError_Tags.Error;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super("MithrasCryptoError", "Error");
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Error_ {
      return new Error_(v0);
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === MithrasCryptoError_Tags.Error;
    }

    static hasInner(obj: any): obj is Error_ {
      return Error_.instanceOf(obj);
    }

    static getInner(obj: Error_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is MithrasCryptoError {
    return obj[uniffiTypeNameSymbol] === "MithrasCryptoError";
  }

  return Object.freeze({
    instanceOf,
    Error: Error_,
  });
})();

export type MithrasCryptoError = InstanceType<
  (typeof MithrasCryptoError)[keyof Omit<
    typeof MithrasCryptoError,
    "instanceOf"
  >]
>;

// FfiConverter for enum MithrasCryptoError
const FfiConverterTypeMithrasCryptoError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MithrasCryptoError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MithrasCryptoError.Error(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MithrasCryptoError_Tags.Error: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that MithrasCryptoError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MithrasCryptoError_Tags.Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface MithrasAddrInterface {
  encode(): string;
}

export class MithrasAddr
  extends UniffiAbstractObject
  implements MithrasAddrInterface
{
  readonly [uniffiTypeNameSymbol] = "MithrasAddr";
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeMithrasAddrObjectFactory.bless(pointer);
  }

  public static decode(s: string): MithrasAddrInterface /*throws*/ {
    return FfiConverterTypeMithrasAddr.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeMithrasCryptoError.lift.bind(
          FfiConverterTypeMithrasCryptoError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_constructor_mithrasaddr_decode(
            FfiConverterString.lower(s),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public static fromKeys(
    ed25519SpendPubkey: ArrayBuffer,
    x25519DiscoveryPubkey: ArrayBuffer,
    version: /*u8*/ number,
    network: string,
    suite: /*u8*/ number,
  ): MithrasAddrInterface {
    return FfiConverterTypeMithrasAddr.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_constructor_mithrasaddr_from_keys(
            FfiConverterArrayBuffer.lower(ed25519SpendPubkey),
            FfiConverterArrayBuffer.lower(x25519DiscoveryPubkey),
            FfiConverterUInt8.lower(version),
            FfiConverterString.lower(network),
            FfiConverterUInt8.lower(suite),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public encode(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_method_mithrasaddr_encode(
            uniffiTypeMithrasAddrObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeMithrasAddrObjectFactory.pointer(this);
      uniffiTypeMithrasAddrObjectFactory.freePointer(pointer);
      uniffiTypeMithrasAddrObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is MithrasAddr {
    return uniffiTypeMithrasAddrObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeMithrasAddrObjectFactory: UniffiObjectFactory<MithrasAddrInterface> =
  (() => {
    /// <reference lib="es2021" />
    const registry =
      typeof FinalizationRegistry !== "undefined"
        ? new FinalizationRegistry<UnsafeMutableRawPointer>(
            (heldValue: UnsafeMutableRawPointer) => {
              uniffiTypeMithrasAddrObjectFactory.freePointer(heldValue);
            },
          )
        : null;

    return {
      create(pointer: UnsafeMutableRawPointer): MithrasAddrInterface {
        const instance = Object.create(MithrasAddr.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "MithrasAddr";
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        const ptr = {
          p, // make sure this object doesn't get optimized away.
          markDestroyed: () => undefined,
        };
        if (registry) {
          registry.register(ptr, p, ptr);
        }
        return ptr;
      },

      unbless(ptr: UniffiRustArcPtr) {
        if (registry) {
          registry.unregister(ptr);
        }
      },

      pointer(obj: MithrasAddrInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: MithrasAddrInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_clone_mithrasaddr(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_free_mithrasaddr(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      isConcreteType(obj: any): obj is MithrasAddrInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === "MithrasAddr"
        );
      },
    };
  })();
// FfiConverter for MithrasAddrInterface
const FfiConverterTypeMithrasAddr = new FfiConverterObject(
  uniffiTypeMithrasAddrObjectFactory,
);

export interface UtxoInputsInterface {
  envelope(): HpkeEnvelope;
  secrets(): UtxoSecretsInterface;
}

export class UtxoInputs
  extends UniffiAbstractObject
  implements UtxoInputsInterface
{
  readonly [uniffiTypeNameSymbol] = "UtxoInputs";
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUtxoInputsObjectFactory.bless(pointer);
  }

  public static generate(
    txnMetadata: TransactionMetadata,
    amount: /*u64*/ bigint,
    receiver: MithrasAddrInterface,
  ): UtxoInputsInterface /*throws*/ {
    return FfiConverterTypeUtxoInputs.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeMithrasCryptoError.lift.bind(
          FfiConverterTypeMithrasCryptoError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_constructor_utxoinputs_generate(
            FfiConverterTypeTransactionMetadata.lower(txnMetadata),
            FfiConverterUInt64.lower(amount),
            FfiConverterTypeMithrasAddr.lower(receiver),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public envelope(): HpkeEnvelope {
    return FfiConverterTypeHpkeEnvelope.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_method_utxoinputs_envelope(
            uniffiTypeUtxoInputsObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public secrets(): UtxoSecretsInterface {
    return FfiConverterTypeUtxoSecrets.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_method_utxoinputs_secrets(
            uniffiTypeUtxoInputsObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUtxoInputsObjectFactory.pointer(this);
      uniffiTypeUtxoInputsObjectFactory.freePointer(pointer);
      uniffiTypeUtxoInputsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UtxoInputs {
    return uniffiTypeUtxoInputsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUtxoInputsObjectFactory: UniffiObjectFactory<UtxoInputsInterface> =
  (() => {
    /// <reference lib="es2021" />
    const registry =
      typeof FinalizationRegistry !== "undefined"
        ? new FinalizationRegistry<UnsafeMutableRawPointer>(
            (heldValue: UnsafeMutableRawPointer) => {
              uniffiTypeUtxoInputsObjectFactory.freePointer(heldValue);
            },
          )
        : null;

    return {
      create(pointer: UnsafeMutableRawPointer): UtxoInputsInterface {
        const instance = Object.create(UtxoInputs.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "UtxoInputs";
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        const ptr = {
          p, // make sure this object doesn't get optimized away.
          markDestroyed: () => undefined,
        };
        if (registry) {
          registry.register(ptr, p, ptr);
        }
        return ptr;
      },

      unbless(ptr: UniffiRustArcPtr) {
        if (registry) {
          registry.unregister(ptr);
        }
      },

      pointer(obj: UtxoInputsInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: UtxoInputsInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_clone_utxoinputs(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_free_utxoinputs(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      isConcreteType(obj: any): obj is UtxoInputsInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === "UtxoInputs"
        );
      },
    };
  })();
// FfiConverter for UtxoInputsInterface
const FfiConverterTypeUtxoInputs = new FfiConverterObject(
  uniffiTypeUtxoInputsObjectFactory,
);

export interface UtxoSecretsInterface {
  nullifierSecret(): ArrayBuffer;
  spendingSecret(): ArrayBuffer;
}

export class UtxoSecrets
  extends UniffiAbstractObject
  implements UtxoSecretsInterface
{
  readonly [uniffiTypeNameSymbol] = "UtxoSecrets";
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUtxoSecretsObjectFactory.bless(pointer);
  }

  public static fromHpkeEnvelope(
    hpkeEnvelope: HpkeEnvelope,
    discoveryPubkey: ArrayBuffer,
    discoeryPrivley: ArrayBuffer,
    txnMetadata: TransactionMetadata,
  ): UtxoSecretsInterface {
    return FfiConverterTypeUtxoSecrets.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_constructor_utxosecrets_from_hpke_envelope(
            FfiConverterTypeHpkeEnvelope.lower(hpkeEnvelope),
            FfiConverterArrayBuffer.lower(discoveryPubkey),
            FfiConverterArrayBuffer.lower(discoeryPrivley),
            FfiConverterTypeTransactionMetadata.lower(txnMetadata),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public nullifierSecret(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_method_utxosecrets_nullifier_secret(
            uniffiTypeUtxoSecretsObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public spendingSecret(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_method_utxosecrets_spending_secret(
            uniffiTypeUtxoSecretsObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUtxoSecretsObjectFactory.pointer(this);
      uniffiTypeUtxoSecretsObjectFactory.freePointer(pointer);
      uniffiTypeUtxoSecretsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UtxoSecrets {
    return uniffiTypeUtxoSecretsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUtxoSecretsObjectFactory: UniffiObjectFactory<UtxoSecretsInterface> =
  (() => {
    /// <reference lib="es2021" />
    const registry =
      typeof FinalizationRegistry !== "undefined"
        ? new FinalizationRegistry<UnsafeMutableRawPointer>(
            (heldValue: UnsafeMutableRawPointer) => {
              uniffiTypeUtxoSecretsObjectFactory.freePointer(heldValue);
            },
          )
        : null;

    return {
      create(pointer: UnsafeMutableRawPointer): UtxoSecretsInterface {
        const instance = Object.create(UtxoSecrets.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "UtxoSecrets";
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        const ptr = {
          p, // make sure this object doesn't get optimized away.
          markDestroyed: () => undefined,
        };
        if (registry) {
          registry.register(ptr, p, ptr);
        }
        return ptr;
      },

      unbless(ptr: UniffiRustArcPtr) {
        if (registry) {
          registry.unregister(ptr);
        }
      },

      pointer(obj: UtxoSecretsInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: UtxoSecretsInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_clone_utxosecrets(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_mithras_crypto_ffi_fn_free_utxosecrets(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      isConcreteType(obj: any): obj is UtxoSecretsInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === "UtxoSecrets"
        );
      },
    };
  })();
// FfiConverter for UtxoSecretsInterface
const FfiConverterTypeUtxoSecrets = new FfiConverterObject(
  uniffiTypeUtxoSecretsObjectFactory,
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_mithras_crypto_ffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion,
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_method_mithrasaddr_encode() !==
    2677
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_method_mithrasaddr_encode",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_method_utxoinputs_envelope() !==
    54352
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_method_utxoinputs_envelope",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_method_utxoinputs_secrets() !==
    6253
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_method_utxoinputs_secrets",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_method_utxosecrets_nullifier_secret() !==
    43989
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_method_utxosecrets_nullifier_secret",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_method_utxosecrets_spending_secret() !==
    60388
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_method_utxosecrets_spending_secret",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_constructor_mithrasaddr_decode() !==
    62241
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_constructor_mithrasaddr_decode",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_constructor_mithrasaddr_from_keys() !==
    47992
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_constructor_mithrasaddr_from_keys",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_constructor_utxoinputs_generate() !==
    6164
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_constructor_utxoinputs_generate",
    );
  }
  if (
    nativeModule().ubrn_uniffi_mithras_crypto_ffi_checksum_constructor_utxosecrets_from_hpke_envelope() !==
    49676
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_mithras_crypto_ffi_checksum_constructor_utxosecrets_from_hpke_envelope",
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeHpkeEnvelope,
    FfiConverterTypeMithrasAddr,
    FfiConverterTypeMithrasCryptoError,
    FfiConverterTypeTransactionMetadata,
    FfiConverterTypeUtxoInputs,
    FfiConverterTypeUtxoSecrets,
  },
});
