# This script (dev/test flow):
# 1) Ensures a Phase2-ready Powers-of-Tau file exists (BLS12-381, power 16) via ../ceremonies/test/setup.sh.
# 2) Compiles each circom circuit to artifacts (notably .r1cs + witness generator .wasm).
# 3) Checks the chosen .ptau “power” is large enough for each compiled .r1cs (based on nConstraints).
# 4) Runs Groth16 setup to produce circuit-specific .zkey files (deposit_test.zkey / spend_test.zkey).
#
# Notes:
# - The setup output is fine for local testing, but for real security you should run
#   `snarkjs zkey contribute ...` (and/or beacon) to finalize the zkey.

cd $(dirname "$0")
CIRCUITS_DIR=$(pwd)

set -euo pipefail

SNARKJS_PROJECT_DIR="$CIRCUITS_DIR/.."

resolve_snarkjs_cmd() {
	local bin_path="$SNARKJS_PROJECT_DIR/node_modules/.bin/snarkjs"
	local cli_path="$SNARKJS_PROJECT_DIR/node_modules/snarkjs/build/cli.cjs"

	if [ -x "$bin_path" ]; then
		echo "$bin_path"
		return 0
	fi

	if [ -f "$cli_path" ]; then
		echo "node|$cli_path"
		return 0
	fi

	if command -v snarkjs >/dev/null 2>&1; then
		echo "snarkjs"
		return 0
	fi

	# Fallback: use npx to run snarkjs without installing node_modules in this repo.
	# This is especially helpful in environments where pnpm/corepack isn't set up.
	if command -v npx >/dev/null 2>&1; then
		echo "npx"
		return 0
	fi

	echo ""
}

SNARKJS_CMD_SPEC="$(resolve_snarkjs_cmd)"
if [ -z "$SNARKJS_CMD_SPEC" ]; then
	echo "[zkey.sh] ERROR: Could not find snarkjs." >&2
	echo "[zkey.sh] Expected one of:" >&2
	echo "[zkey.sh]   - $SNARKJS_PROJECT_DIR/node_modules/.bin/snarkjs" >&2
	echo "[zkey.sh]   - $SNARKJS_PROJECT_DIR/node_modules/snarkjs/build/cli.cjs" >&2
	echo "[zkey.sh]   - snarkjs on PATH" >&2
	exit 1
fi

snarkjs() {
	if [[ "$SNARKJS_CMD_SPEC" == node\|* ]]; then
		local cli_path="${SNARKJS_CMD_SPEC#node|}"
		node "$cli_path" "$@"
	elif [[ "$SNARKJS_CMD_SPEC" == "npx" ]]; then
		npx --yes snarkjs "$@"
	else
		"$SNARKJS_CMD_SPEC" "$@"
	fi
}

# sed portability:
# - macOS/BSD sed uses -E for extended regex
# - GNU sed supports -E (modern) and -r (older)
SED_EXTENDED_FLAG="-E"
if ! printf 'x\n' | sed -E 's/x/x/' >/dev/null 2>&1; then
	SED_EXTENDED_FLAG="-r"
fi

get_r1cs_constraints() {
	local r1cs="$1"
	# snarkjs output format varies slightly by version; try a few patterns.
	snarkjs r1cs info "$r1cs" \
		| sed -n "$SED_EXTENDED_FLAG" \
			-e 's/.*nConstraints[^0-9]*([0-9]+).*/\1/p' \
			-e 's/.*# of Constraints[^0-9]*([0-9]+).*/\1/p' \
			-e 's/.*Constraints[^0-9]*([0-9]+).*/\1/p' \
		| head -n 1
}

get_ptau_power() {
	local ptau="$1"
	# snarkjs 0.7.x does not provide `powersoftau info`, so infer the power from the
	# ptau binary layout printed by `snarkjs file info`.
	#
	# For BLS12-381 ptau files generated by snarkjs, section #2 stores TauG1 as
	# uncompressed G1 points (96 bytes each) and contains (2^(power+1) - 1) points.
	local section2_size
	section2_size="$(snarkjs file info "$ptau" \
		| sed -n "$SED_EXTENDED_FLAG" -e 's/^section[[:space:]]+#2[[:space:]]+size:[[:space:]]*([0-9]+).*/\1/p' \
		| head -n 1)"

	if [ -n "${section2_size:-}" ]; then
		local bytes_per_g1=96
		if [ $((section2_size % bytes_per_g1)) -eq 0 ]; then
			local points=$((section2_size / bytes_per_g1))
			local n=$((points + 1))
			local exp=0
			local v=1
			while [ "$v" -lt "$n" ]; do
				v=$((v * 2))
				exp=$((exp + 1))
			done
			if [ "$v" -eq "$n" ] && [ "$exp" -ge 1 ]; then
				echo $((exp - 1))
				return 0
			fi
		fi
	fi

	# Fallback: try to infer from common filename conventions (e.g. pot16_final.ptau)
	basename "$ptau" \
		| sed -n "$SED_EXTENDED_FLAG" -e 's/^pot([0-9]+)_.*\.ptau$/\1/p' \
		| head -n 1
}

ceil_log2() {
	# Smallest p such that 2^p >= n (n >= 1)
	local n="$1"
	local p=0
	local v=1
	while [ "$v" -lt "$n" ]; do
		v=$((v * 2))
		p=$((p + 1))
	done
	echo "$p"
}

check_ptau_fits_r1cs() {
	local r1cs="$1"
	local ptau="$2"

	local constraints
	constraints="$(get_r1cs_constraints "$r1cs")"
	if [ -z "${constraints:-}" ]; then
		echo "[zkey.sh] WARN: Could not parse constraints from: $r1cs" >&2
		echo "[zkey.sh]       Run: snarkjs r1cs info '$r1cs'" >&2
		return 0
	fi

	local power
	power="$(get_ptau_power "$ptau")"
	if [ -z "${power:-}" ]; then
		echo "[zkey.sh] WARN: Could not parse ptau power from: $ptau" >&2
		echo "[zkey.sh]       Run: snarkjs powersoftau info '$ptau'" >&2
		return 0
	fi

	# Rule of thumb for Groth16 setups: ptau power should be >= ceil(log2(nConstraints)).
	# Using nConstraints (not wires) is a conservative/standard sizing check.
	local required_power
	required_power="$(ceil_log2 "$constraints")"

	if [ "$required_power" -gt "$power" ]; then
		echo "[zkey.sh] ERROR: ptau too small for circuit." >&2
		echo "[zkey.sh]   r1cs: $r1cs" >&2
		echo "[zkey.sh]   constraints: $constraints" >&2
		echo "[zkey.sh]   ptau: $ptau (power=$power)" >&2
		echo "[zkey.sh]   required power >= $required_power" >&2
		echo "[zkey.sh] Hint: bump ceremonies/test/setup.sh to a larger power (e.g. 17/18), then regenerate pot*.ptau." >&2
		exit 1
	fi

	echo "[zkey.sh] OK: $r1cs constraints=$constraints fits ptau power=$power (required>=$required_power)"
}

bash ../ceremonies/test/setup.sh

PTAU_PATH="$CIRCUITS_DIR/../ceremonies/test/pot16_final.ptau"

# circom --r1cs --wasm --c --sym --inspect $CIRCUITS_DIR/deposit.circom --prime bls12381
circom --r1cs --wasm --c --sym --inspect "$CIRCUITS_DIR/deposit.circom" --prime bn128
check_ptau_fits_r1cs "$CIRCUITS_DIR/deposit.r1cs" "$PTAU_PATH"
# snarkjs plonk setup $CIRCUITS_DIR/deposit.r1cs $PTAU_PATH $CIRCUITS_DIR/deposit_test.zkey
snarkjs groth16 setup $CIRCUITS_DIR/deposit.r1cs $PTAU_PATH $CIRCUITS_DIR/deposit_test.zkey

# circom --r1cs --wasm --c --sym --inspect $CIRCUITS_DIR/spend.circom --prime bls12381
circom --r1cs --wasm --c --sym --inspect "$CIRCUITS_DIR/spend.circom" --prime bn128
check_ptau_fits_r1cs "$CIRCUITS_DIR/spend.r1cs" "$PTAU_PATH"
# snarkjs plonk setup $CIRCUITS_DIR/spend.r1cs $PTAU_PATH $CIRCUITS_DIR/spend_test.zkey
snarkjs groth16 setup $CIRCUITS_DIR/spend.r1cs $PTAU_PATH $CIRCUITS_DIR/spend_test.zkey